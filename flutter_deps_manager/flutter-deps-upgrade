#!/bin/bash

# Flutter Dependencies Upgrade CLI Tool
# Professional CLI interface for intelligent Flutter dependency upgrading
# Supports monorepo and standalone project detection with unified resolution

set -euo pipefail

# Version and metadata
VERSION="1.0.0"
SCRIPT_NAME="flutter-deps-upgrade"
# Determine the library directory
if [[ -d "/usr/local/lib/flutter-deps-upgrade" ]]; then
    # System-wide installation
    SCRIPT_DIR="/usr/local/lib/flutter-deps-upgrade"
elif [[ -d "$HOME/.local/lib/flutter-deps-upgrade" ]]; then
    # User installation
    SCRIPT_DIR="$HOME/.local/lib/flutter-deps-upgrade"
else
    # Fallback: try relative to script location (development)
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Output functions
print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }
print_header() { echo -e "${CYAN}${BOLD}$1${NC}"; }

# Global flags
DRY_RUN=false
VERBOSE=false
ALL_PROJECTS=false
QUIET=false
CONFIG_FILE=""
VALIDATE_BUILD=false
VALIDATE_QUICK=true

# Load the core functionality
source "${SCRIPT_DIR}/core-functions.sh" 2>/dev/null || {
    print_error "Core functionality script not found: ${SCRIPT_DIR}/core-functions.sh"
    exit 1
}

show_version() {
    echo "${SCRIPT_NAME} v${VERSION}"
    echo "Intelligent Flutter Dependency Upgrader"
}

show_usage() {
    cat << EOF
${BOLD}Flutter Dependencies Upgrade CLI Tool${NC}
Intelligent dependency upgrader with automatic monorepo detection

${BOLD}USAGE:${NC}
    ${SCRIPT_NAME} [COMMAND] [OPTIONS] [TARGET]

${BOLD}COMMANDS:${NC}
    analyze [TARGET]         Analyze and preview dependency upgrades (dry-run)
    upgrade [TARGET]         Apply dependency upgrades
    version                  Show version information
    help                     Show this help message

${BOLD}TARGETS:${NC}
    <project-path>          Specific project directory (e.g., 'app', 'packages/core')
    --all                   All projects in current directory
    (none)                  Interactive menu to choose

${BOLD}OPTIONS:${NC}
    -h, --help              Show help message
    -v, --verbose           Verbose output
    -q, --quiet             Quiet output (errors only)
    -c, --config FILE       Load configuration from file
    --validate              Run full build validation after upgrade
    --no-validate           Skip post-upgrade validation
    --version               Show version information

${BOLD}EXAMPLES:${NC}
    ${SCRIPT_NAME} analyze                    # Interactive: choose project to analyze
    ${SCRIPT_NAME} analyze app                # Analyze specific project
    ${SCRIPT_NAME} analyze --all              # Analyze all projects
    ${SCRIPT_NAME} upgrade packages/core      # Upgrade specific project
    ${SCRIPT_NAME} upgrade --all --verbose    # Upgrade all projects with verbose output
    ${SCRIPT_NAME} upgrade app --validate     # Upgrade with full build validation

${BOLD}DETECTION:${NC}
    üîç ${BOLD}MONOREPO${NC} (has path dependencies) ‚Üí Unified resolution strategy
    üì¶ ${BOLD}STANDALONE${NC} (no path dependencies) ‚Üí Individual resolution strategy

${BOLD}SAFETY:${NC}
    ‚úÖ Automatic backups before changes
    ‚úÖ Dry-run mode to preview changes  
    ‚úÖ Automatic rollback if failures occur
    ‚úÖ Skips git/path dependencies (preserves local packages)

EOF
}

load_config() {
    local config_file="$1"
    
    if [[ ! -f "$config_file" ]]; then
        print_error "Configuration file not found: $config_file"
        exit 1
    fi
    
    print_info "Loading configuration from: $config_file"
    
    # Simple key=value config parser
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ $key =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue
        
        # Remove quotes and whitespace
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs | sed 's/^["'"'"']//;s/["'"'"']$//')
        
        case "$key" in
            "verbose") VERBOSE="$value" ;;
            "quiet") QUIET="$value" ;;
            "backup_dir") BACKUP_DIR="$value" ;;
            *) print_warning "Unknown config key: $key" ;;
        esac
    done < "$config_file"
}

parse_arguments() {
    # Parse command first
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        "analyze"|"preview"|"dry-run")
            DRY_RUN=true
            ;;
        "upgrade"|"apply")
            DRY_RUN=false
            ;;
        "version"|"--version")
            show_version
            exit 0
            ;;
        "help"|"--help"|"-h")
            show_usage
            exit 0
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            show_usage
            exit 1
            ;;
    esac
    
    # Parse options and target
    local target=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            -c|--config)
                CONFIG_FILE="$2"
                shift 2
                ;;
            --all)
                ALL_PROJECTS=true
                shift
                ;;
            --validate)
                VALIDATE_BUILD=true
                VALIDATE_QUICK=true
                shift
                ;;
            --no-validate)
                VALIDATE_BUILD=false
                VALIDATE_QUICK=false
                shift
                ;;
            --version)
                show_version
                exit 0
                ;;
            -*)
                print_error "Unknown option: $1"
                exit 1
                ;;
            *)
                if [[ -n "$target" ]]; then
                    print_error "Multiple targets specified: '$target' and '$1'"
                    exit 1
                fi
                target="$1"
                shift
                ;;
        esac
    done
    
    # Load config file if specified
    if [[ -n "$CONFIG_FILE" ]]; then
        load_config "$CONFIG_FILE"
    fi
    
    # Export validation flags for core functions
    export VALIDATE_BUILD VALIDATE_QUICK
    
    # Override core functions with CLI integration
    override_core_functions
    
    # Execute the appropriate action
    execute_command "$target"
}

execute_command() {
    local target="$1"
    
    # Validate arguments first
    if [[ "$ALL_PROJECTS" == "true" ]] && [[ -n "$target" ]]; then
        print_error "Cannot specify both --all and a specific target"
        exit 1
    fi
    
    if [[ -n "$target" ]]; then
        if [[ ! -d "$target" ]]; then
            print_error "Directory not found: $target"
            exit 1
        fi
        
        if [[ ! -f "$target/pubspec.yaml" ]]; then
            print_error "No pubspec.yaml found in: $target"
            exit 1
        fi
    fi
    
    # Show header after validation
    if [[ "$DRY_RUN" == "true" ]]; then
        print_header "üîç Analyzing Dependencies"
    else
        print_header "üöÄ Upgrading Dependencies"
    fi
    
    # Handle different target modes
    if [[ "$ALL_PROJECTS" == "true" ]]; then
        execute_all_projects
    elif [[ -n "$target" ]]; then
        execute_single_project "$target"
    else
        execute_interactive
    fi
}

execute_all_projects() {
    if [[ "$DRY_RUN" == "true" ]]; then
        upgrade_all_projects "dry-run"
    else
        upgrade_all_projects "upgrade"
    fi
}

execute_single_project() {
    local target="$1"
    
    # Use the existing upgrade function
    upgrade_all_dependencies "$target"
    local exit_code=$?
    
    if [[ $exit_code -ne 0 ]]; then
        print_error "Failed to upgrade dependencies for: $target"
        exit $exit_code
    fi
}

execute_interactive() {
    if [[ "$DRY_RUN" == "true" ]]; then
        show_pubspec_menu "dry-run"
    else
        show_pubspec_menu "upgrade"
    fi
}

# Override core functions for CLI integration
override_core_functions() {
    # Override print functions to respect quiet mode
    print_info() { 
        [[ "$QUIET" == "true" ]] && return
        echo -e "${BLUE}[INFO]${NC} $1" 
    }
    
    print_success() { 
        [[ "$QUIET" == "true" ]] && return
        echo -e "${GREEN}[SUCCESS]${NC} $1" 
    }
    
    print_warning() { 
        echo -e "${YELLOW}[WARNING]${NC} $1" 
    }
    
    print_error() { 
        echo -e "${RED}[ERROR]${NC} $1" >&2
    }
}

# Main execution
main() {
    # Check if we're in a Flutter project
    if [[ ! -f "pubspec.yaml" && ! -d "packages" && ! -f "*/pubspec.yaml" ]]; then
        print_warning "No Flutter projects detected in current directory"
        print_info "Run this command from a Flutter project root or monorepo root"
    fi
    
    parse_arguments "$@"
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi